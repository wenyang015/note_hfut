# 函数：
## 结构化程序设计：
## 简介：结构化程序设计是一种要求自顶向下、自下而上反复求精的设计方法
- 优点：函数实现的功能单一完整，可以独立设计，单独调试，易于维护，通用性强
### 名词介绍：
- 模块： 在C语言中表现为函数
- 接口：各种模块之间的的关系
- main()函数是主函数，是C语言程序的入口
### 函数的基本结构：
    格式：
    type 函数名称(参数说明表){
        内部说明语句;
        功能语句;
    }
- 如果函数有返回值，应含有return 语句
- 如果函数没有返回值，那么type 就应该说明为void空类型
- 如果函数没有参数，那么就应该将函数参数说明表定义为void
### 函数的调用：
    调用方式：
    函数名称 (实参数);
- 函数可以嵌套引用，也包括引用自己(称为递归调用)
- 调用过程：先计算实参的值，从右向左向函数传递赋值给形参
### 关于返回值的几点说明：
- 函数可以通过一个return语句来返回一个值，也可以不返回值，此时在定义函数时就需要使用void来定义type;
- 函数可以包括多个return 语句,当遇到一个return 语句时，则返回值，且返回调用函数，继续执行
- 返回值的类型应与函数的类型一致，如果不一样，以函数类型为准，先转换为函数类型后，再返回
- 为了确保参数和返回值类型正确，一般需要在函数调用前对其类型和参数的类型加以说明，该说明称为原型说明
### 变量的存储类型以及作用域：
- 变量时内存数据的抽象，即将内存地址、数据表示抽象成为一个符号，此外，变量还有存储类型，存储类型确定了变量在时间上的生存和空间上的作用域
- 变量的存储类型：
- 静态存储类型：static
- 自动存储类型：auto
- 寄存器存储类型：register
- 函数存储类型：extern
#### 变量说明格式：
    存储类型 类型 变量表名;// 存储类型省略时表示是auto 类型
#### auto存储类型：
- 定义在复合语句的开头处，如果在定义变量时没有指定存储类型，那么就默认为auto类型
- 作用域是整个块语句
- 生存周期：auto变量的生存周期是从定义该变量的函数或代码块被执行时开始，到该函数或代码块执行结束时结束。这意味着每次函数被调用时，auto变量都会被创建和销毁，其存储空间会在函数返回时自动释放。
#### register存储类型：
- 作用域与生存周期与auto相同
- 作用：register变量在编译时，会直接存储在寄存器中，从而加快访问速度，主要用于循环变量
#### static存储类型：
- 作用域：在定义的符合语句内引用，出了复合语句**不可见**
- 生存周期：从定义知道程序结束，执行出{}时,原来的值并不消失，只是不能够被引用
#### extern存储类型：
- 作用域：从定义直到文件执行结束
- 外部变量是定义在任何模块之外的变量，也称为全局变量
- 生存周期：在程序的整个执行过程中，任何函数对外部变量的修改都会影响其他函数对外部变量应用时的值
##### 关于外部变量的几点说明：
- 外部变量可以通过说明来改变其作用域
- 外部变量可以被不同的文件共享，如果只希望在本文件使用，就使用static来进行变量存储类型的说明
- 模块设计的原则：内聚性强，耦合性弱，外部变量的使用占用内存并且增加了模块的耦合性，因此，应尽量不使用外部变量
- 当模块中出现和全局变量同名的局部变量时，局部变量在模块中优先
### 函数间的数据传递
- 函数在调用的过程中：调用函数和被调函数存在数据的相互传递，数据的传递包括两个方面
- 方面一：将值传递给被调函数
- 方面二：将被调函数的结果返回给调用函数
#### 数据传递方式：
- 通过函数参数传值与返回值
- 不通过参数，直接用全局变量共享（不推荐使用这种方式）
- 通过函数（指针）参数传地址与返回地址
##### 使用参数传递数据：
- 传值方式：通过实参与形参的结合，将数据值传递给形参，形参的改变不影响实参
##### 外部变量传递参数：
- 定义外部变量被调用函数和被调用函数共享，任何函数对外部变量的修改都会影响到其他函数所见的外部变量的值
- 应尽量少用外部变量，因为外部变量的修改会影响到其他函数，如果函数之间有依赖，那么就会造成耦合性，导致模块的复用性变差
#### 递归函数；
- 递归函数：函数调用自己，函数调用自己，函数调用自己，知道函数执行结束。函数直接或间接地调用自己
- 只有通过控制条件，是递归调用终止，才能应用
#### 编译预处理：
- C语言除了说明语句、执行语句以及控制语句之外还有一类编译预处理语句，该类语句的作用是在编译时对程序做一定的处理，满足特定的处理要求
- 编译预处理的语法格式
-     # 关键字 参数表
- 编译预处理语句不用;作为结束标志
##### 宏定义预处理：
- 不带参数的宏定义：
- 作用：定义常量名，提高程序的可读性，便于修改
- 格式：# define 宏名 字符串
-     # define PI 3.1415926
- 宏名一般要大写
- 编译时用字符串无条件替代宏名
- 宏名的有效范围，从定义到程序尾，也可以通过# undef修改定义范围
-     # define G 9.8
-     void main(void){
-     ...
-     }
-     undef G
- 可以在宏定义的字符串中使用已经定义的宏名
- " "字符串中的宏名不替换
#### 带参数的宏定义：
- 格式：# define 宏名(参数表) 含参数的字符串
-     # define S(a, b) a * b
- 替换过程：
- 将实际参数替换宏定义的参数
- 替换字符串中的参数
- 替换整个宏
- 带参数的宏与函数的区别：
- 带参宏不分配内存单元，不返回值，只是在编译时会按照规则进行替换
- 要严格按照格式来进行书写，否则可能造成错误
- 参数可能用到表达式时，参数字符要加上()
#### 文件包含：
- 格式：
-     # include <被包含的文件名称> // <>表示系统定义路径
-     # include "被包含的文件名称" // ""表示用户指定路径
- 作用：将指定的文件的内容和当前文件一起编译
- 说明：
- 一个#include 只能包含一个文件
- 被包含文件可以嵌套包含文件
- 一般将宏定义以及函数的原型声明放在包含文件中
- 被包含的文件一般拓展名为.h,称为头文件
#### 条件编译：
- C语言可以通过条件控制，让编译系统编译不同的程序段，从而提高程序的移植性并且方便进行调试
- 条件编译的三种方式
  - 方式一：
  -     # ifdef 标识符
        program seg1;
        # else
        program seg2;
        # endif
  - 方式二:
  -     # ifndef 标识符
        program seg1;
        # else 
        program seg2;
        # endif
  - 方式三：
  -     # if 表达式
        program seg1;
        # else
        program seg2
        # endif