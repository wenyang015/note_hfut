# 实验一：

## 加法器模块的实现

### 一位全加器

#### 原理：通过数电中的公式，两个一位的二进制数a,b相加，同时还有来自上个运算所得到的进位c_in，相加之后会产生进位c_out，通过数电的公式可知，c_out = (a&b)|(a&c_in)|(b&c_in),同时最终保留的一位数字sum = (a^b^c_in);

$$
c\_out=(a\bigwedge{b})\bigvee(a\bigwedge{c})\bigvee(b\bigwedge{c});
sum=(a\bigoplus{b}\bigoplus{c})
$$

### 一位全加器代码实现：

```verilog
module adder1(a, b, c_in, c_out, sum);
    input a;
    input b;
    input c_in;
    output c_out;
    output sum;
    always @(*) begin
        sum <= (a^b^c_in);
        c_out <= (a&b)|(a&c_in)|(b&c_in);
    end
endmodule
```

### 四位全加器

#### 原理：四位全加器可以通过四个一位全加器来进行实现，首先输入两个四位的二进制数，然后输入一个进位数字c_in,对于每一位相加可以看做两个二进制数进行相加，所以需要使用一位全加器，然后产生的一个进位就需要看成第二位的输入进位(相当于第一位的c_in)，然后以此类推，这样就需要三位的变量来存储每一位相加产生的进位(第一位相加，第二位相加，第三位相加)，第四位相加就将其视为最终的输出进位c_out，每一位相加后保留一位结果就是每一位的sum，四位组合起来就是整体的sum

### 四位全加器代码实现

```verilog
module adder4(a, b, c_in, c_out, sum);
    input [3:0] a;
    input [3:0] b;
    input c_in;
    output [3:0] sum;
    output c_out;
    reg [3:0] temp;
    always @(*) begin
        adder1 one(.a(a[0]), .b(b[0]), .c_in(c_in), .c_out(temp[0]), .sum(sum[0]));
        adder1 two(.a(a[1]), .b(b[1]), .c_in(temp[0]), .c_out(temp[1]), .sum(sum[1]));
        adder1 three(.a(a[2]), .b(b[2]), .c_in(temp[1]), .c_out(temp[2]), .sum(sum[2]));
        adder1 four(.a(a[3]), .b(b[3]), .c_in(temp[2]), .c_out(c_out), .sum(sum[3]));
    end
endmodule
```

### 十六位全加器：

#### 原理：十六位全加器可以通过四个四位全加器进行实现，或者十六个一位全加器进行实现，也就是说任何整数位全加器都可以由一位全加器扩展得到，对于由四个四位全加器的构建思路同上，只不过每次传递的参数位数不一样，比如16位全加器传入前四位a,应该传入a[3:0]，传入前四位b，应该传入b[3:0]，输出前四位sum，应该传出sum[3:0]，同时还需要一个三位的寄存器来保存中间进位进行传递，最终输出进位还是一位。

```verilog
module adder16(a, b, c_in, c_out, sum);
    input [15:0] a;
    input [15:0] b;
    input c_in;
    output c_out;
    output [15:0] sum;
    reg temp[2:0];
    always @(*) begin
        adder4 one(.a(a[3:0]), .b(b[3:0]), .c_in(c_in), .c_out(temp[0]), .sum(sum[3:0]));
        adder4 two(.a(a[7:4]), .b(b[7:4]), .c_in(temp[0]), .c_out(temp[1]), .sum(sum[7:4]));
        adder4 three(.a(a[11:8]), .b(b[11:8]), .c_in(temp[1]), .c_out(temp[2]), .sum(sum[11:8]));
        adder5 four(.a(a[15:12]), .b(b[15:12]), .c_in(temp[2]), .c_out(c_out), .sum(sum[15:12]));
    end
endmodule
```

