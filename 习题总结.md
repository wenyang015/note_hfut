# part1:
- verilog 是用于**硬件设计**和**仿真**功能的**硬件描述语言**编程语言
- verilog RTL级描述用于**高级抽象级别的集成电路设计**或者用于必须精确到**门级**的模型建模
- verilog适合**数字逻辑电路**的设计
- 用HDL设计的数字系统需要经过**逻辑综合、布局布线、版图生成、后端验证** 才能与具体电路相对应
- 基于硬件描述语言的数字系统设计目前最常用的设计方法称为**TOP-DOWN设计方法**
- verilog的基本构建模型的基本单位是**模块**，它们之间通过**端口**的连接进行相互通信
- 仿真时两个性质不同的模块是**设计模块** 和 **测试模块(testfixture)(testbench)**
- 在testbench中用到的两类过程语句是**initial**和**always**语句
- 其不同处是initial**只执行一次**，而always**循环**执行
# part2:
- verilog程序的四个主要部分分别为**模块定义**，**端口声明**，**数据类型定义**，**行为或者结构描述**
- 模块的端口表示的是模块的**输入输出接口**
- 在进行模块引用时，其端口可以用**两种**方法进行连接，**直接连接和使用.NET声明连接**
- verilog程序内功能定义可以使用**连续赋值语句**和**过程块语句（如always块）**
- 在verilog语言中，例化一个模块的物理意义在于，在更高级的设计中创建了一个下级模块的实例。这允许设计者将复杂的数字系统分解为多个可以管理的部分（模块），每个部分都有明确的功能。通过端口映射，上级模块与下级模块的信号相连，从而实现模块之间的通信和数据交换，这样不仅提高了设计的可读性和可维护性，也便于设计重用和模块化验证
- 标识符：
- Help正确
- 2nd_item错误，以数字开头错误，标识符开头只能是字母和下划线，不能是数字
- casex错误，casex是verilog中的关键字，是case语句的变体，主要用于处理不定态(X)和(Z)的情况。
- integer错误，integer是verilog的预定义数据类型，不能作为用户自定义的标识符
- _na36me正确
- $time：错误，由于 $time是verilog的系统任务。不能作为用户自定义的标识符
- module:错误，由于module是verilog的关键字，用于定义模块，所以不能作为标识符
- 'xy_a:错误，以单引号开头，格式错误
- 7tyr:错误，以数字开头
- myex4 mp,错误，里面有空格
- part3:
- verilog在什么情况下会出现输出为x值：
  - 1：未初始化的信号
  - 2：多驱动情况
  - 3：条件路径不完整
  - 4：三态逻辑
  - 5：仿真初期默认值
  - 6：延迟和竞争条件
  - 7：未综合的代码段
# part3
- 写出下列表达式的值：
  - (20 == 5) ? 8 : (26 > 3) ? 3 : 9; // 3
  - 9 / 6 // 1
  - 4'b0110 & 4'b1100 // 4'b0100
  - 4'b0011 | 4'b1100 // 4'b1111
  - 4'b0011 || 4'b1100 // 1'b1
  - 9%6 // 3
  - 4'b0111 >> 2 // 4'b0001
  - 4'b0111 << 2 // 4'b1100
- 1: ~与!有什么不同：
  - ~是按位取反运算符，同于对单个比特位进行取反的操作，相当于对每一位进行取反的操作
  - !是逻辑取反
- 2：&& 和 &的不同：
  - verilog中的&&运算符是逻辑与操作符
  - &是按位与操作符，用于对两个向量或者标量进行按位与操作，或者可以作为缩减运算符来进行单目操作
- 3：verilog中使用=进行赋值操作，对于连续赋值(如在wire声明中),使用assign关键字，对于寄存器类型的变量，使用阻塞赋值来进行赋值的操作<=,复制数据时，verilog关注的是信号的传递和值的更新时机，而非数据类型兼容性，因为它是基于硬件描述的语言
- 4：连接符的作用：
  - verilog中使用{}作为多路选择器或者向量连接操作符，他可以用来组合或者重新排列信号位。例如，{a[7:0], b[7:0]}会创建一个新的16向量，前八位来自于a,后八位来自于b,这与字符串拼接不同，因为verilog主要用于硬件描述，不直接处理字符串数据 
  - verilog没有直接对于高级语言的字符串连接的概念，因为他主要关注硬件逻辑设计，而不是文本处理，对于文本或字符串操作，可能需要借助于系统函数或者特定的文本处理库来进行处理
- 5:
  - 阻塞赋值(=)：挡在一个always块中使用阻塞赋值时，赋值语句会按照顺序依次进行赋值，赋值语句会按照顺序依次执行。这意味着后面的赋值必须等待前面的赋值结束之后才能开始，这将导致串行操作，不适合描述同时发生的硬件操作
  - 非阻塞赋值(<=)：非阻塞赋值则允许并行操作，在一个时钟边沿，所有的非阻塞赋值语句几乎同时计算新值，但实际上的新值更新是在当前仿真时间点后（通常是在时钟边沿之后）。这模拟了硬件寄存器在同一时钟周期结束后同时更新的特性，适合用于描述并行的逻辑。
  - 举例说明：
    -     always @(posedge clk) begin
            a = a + 1;
            b = a;
          end // 若开始时a = 0，那么在第一个时钟上升沿后，a就会变成1，但由于阻塞赋值特性，b也会被赋值为1，因为是由于阻塞赋值的特性，赋值语句会按照顺序依次进行赋值，赋值语句会按照顺序进行执行，一行语句执行完成之后，变量的值就会更新
    -     always @(posedge clk) begin
            a <= a + 1;
            b <= a;
          end // 使用非阻塞赋值，若a的初始值为0,那么在第一个时钟上升沿后，a就会计划更新为1，b也会由于非阻塞赋值按计划更新为初始值为0,非阻塞赋值变量值的更新实际发生在时钟边沿之后，因此能够正确反映硬件寄存器中的行为
- 6：在顺序块中，如果有一条语句是无限循环，那么在这条无限循环结束之前，下面的语句是无法进行的
- 7：在并行块中，如果在其中一个块语句中有无限循环，其他语句中没有无线循环，那么这个无限循环并不会影响其他块语句的执行，各种并行块语句会独立进行各自的操作，不会受其中一个无限循环的影响二导致后续的语句无法进行
- 8：在verilog中，带有电平敏感列表(如@(sensitivity_list))的always块通常用来描述组合逻辑，即输出直接由当前的输入来进行决定，与过去的状态无关，对于这类描述组合逻辑的always块，推荐使用阻塞赋值，因为这样每个语句执行后，变量的值就会发生更新，而不是在时钟边沿之后才发生变量更新，实现组合逻辑功能
- 9：用带时钟边沿触发条件的always块表示时序电路时，推荐使用非阻塞赋值，从而实现并行操作，非阻塞赋值用于描述硬件中的寄存器或者储存期间的行为，在时钟边沿触发的always块中，所有赋值语句在逻辑上是同时发生的，但实际上新值的更新是发生在时钟边沿之后，这保证了在同一个时钟周期内，所有信号的新值都是基于同一个时钟边沿前的信号状态，符合时序逻辑的实际行为，使用非阻塞赋值可以防止在仿真时因为信号更新顺序不同而导致的不一致问题，尤其是当赋值语句间存在相互依赖时，这有助于仿真结果更好地反映真实硬件的行为。对于FPGA或者ASIC设计，时序逻辑通常映射为触发器或者寄存器，而非阻塞赋值正是为了描述这类硬件结构而设计的，综合工具期望在描述时序逻辑时看到非阻塞赋值，以正确地生成所需的硬件结构。
# part5:
- 1:半加器，全加器，行波进位加法器，超前进位加法器，超前进位加法器通过使用特殊的逻辑电路提前计算多位加法中进位的发生情况，而不依赖于逐位传播。它利用“生成”（Generate, G）和“传播”（Propagate, P）信号的概念，能够在计算高位加法之前预知是否会产生进位，从而并行计算多位的进位，显著减少进位传播的延迟。这种方法有效地缩短了进位链的实际长度，提高了加法运算的速度。
- 2
  - 并行处理不同阶段：在没有流水线的情况下，一个复杂的组合逻辑电路需要等待所有输入信号经过多级逻辑门后，才能得到最终输出，这导致了长的延迟时间，因为信号需要穿越整个逻辑网络，而采用流水线技术，将这个过程分解为多个连续的阶段（或称为"级"）,每个阶段只处理一部分逻辑，这样，不同阶段可以并行处理不同的数据，即时在前一个数据尚未完成整个流程，新的数据也可以开始进行处理
  - 减少关键路径的长度：在组合逻辑中，最长的信号传播路径（即关键路径）决定了整个逻辑的延迟，通过插入寄存器将逻辑进行分割，每个阶段的延迟相对缩短，因为每个阶段的逻辑门数量减少，关键路径变短，这样，即时加上寄存器本身的延迟，总体延迟也可能减少，特别是在处理大量数据时
  - 提高时钟频率：由于每个阶段的延迟减少，整个系统可以以更高的时钟频率运行，这意味着在给定的时间类，可以完成更多周期的计算，从而提高了吞吐量
  - 提高数据吞吐量：在处理连续的数据流时，一旦第一个数据通过了整个流水线，之后的每个时钟周期理论上都可以输出一个结果，因此，尽管单个数据的处理时间可能没有减少，但单位时间内处理的数据量大大增加，即吞吐量大大增加，也就是吞吐量提升
  - 利用时间重叠：流水线的关键在于利用了时间重叠，也称为时间复用，即在处理一个操作的某个阶段，同时为下一个操作的某个阶段做准备，这种重叠使得多个操作的处理过程相互交织，提高了整体的效率
  - 综上所述，流水线技术通过**并行化处理、缩短关键路径、提高时钟频率和增加数据吞吐量和利用时间重叠**，显著提升了复杂组合逻辑运算的速度和效率，特别是在处理大量连续数据或高频率操作的场景下。